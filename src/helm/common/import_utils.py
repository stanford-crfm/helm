"""
This file was autogenerated based on code in :py:mod:`ubelt`.
"""

import os
from os.path import (
    abspath,
    basename,
    dirname,
    exists,
    expanduser,
    isdir,
    join,
    relpath,
    split,
    splitext,
)
import sys
import warnings
import importlib


def normalize_modpath(modpath, hide_init=True, hide_main=False):
    """
    Normalizes __init__ and __main__ paths.

    Args:
        modpath (str | PathLike):
            path to a module

        hide_init (bool):
            if True, always return package modules as __init__.py files
            otherwise always return the dpath. Defaults to True.

        hide_main (bool):
            if True, always strip away main files otherwise ignore __main__.py.
            Defaults to False.

    Returns:
        str | PathLike: a normalized path to the module

    Note:
        Adds __init__ if reasonable, but only removes __main__ by default

    Example:
        >>> from xdoctest import static_analysis as module
        >>> modpath = module.__file__
        >>> assert normalize_modpath(modpath) == modpath.replace('.pyc', '.py')
        >>> dpath = dirname(modpath)
        >>> res0 = normalize_modpath(dpath, hide_init=0, hide_main=0)
        >>> res1 = normalize_modpath(dpath, hide_init=0, hide_main=1)
        >>> res2 = normalize_modpath(dpath, hide_init=1, hide_main=0)
        >>> res3 = normalize_modpath(dpath, hide_init=1, hide_main=1)
        >>> assert res0.endswith('__init__.py')
        >>> assert res1.endswith('__init__.py')
        >>> assert not res2.endswith('.py')
        >>> assert not res3.endswith('.py')
    """
    if hide_init:
        if basename(modpath) == "__init__.py":
            modpath = dirname(modpath)
            hide_main = True
    else:
        # add in init, if reasonable
        modpath_with_init = join(modpath, "__init__.py")
        if exists(modpath_with_init):
            modpath = modpath_with_init
    if hide_main:
        # We can remove main, but dont add it
        if basename(modpath) == "__main__.py":
            # corner case where main might just be a module name not in a pkg
            parallel_init = join(dirname(modpath), "__init__.py")
            if exists(parallel_init):
                modpath = dirname(modpath)
    return modpath


def split_modpath(modpath, check=True):
    """
    Splits the modpath into the dir that must be in PYTHONPATH for the module
    to be imported and the modulepath relative to this directory.

    Args:
        modpath (str): module filepath
        check (bool): if False, does not raise an error if modpath is a
            directory and does not contain an ``__init__.py`` file.

    Returns:
        Tuple[str, str]: (directory, rel_modpath)

    Raises:
        ValueError: if modpath does not exist or is not a package

    Example:
        >>> from xdoctest import static_analysis
        >>> modpath = static_analysis.__file__.replace('.pyc', '.py')
        >>> modpath = abspath(modpath)
        >>> dpath, rel_modpath = split_modpath(modpath)
        >>> recon = join(dpath, rel_modpath)
        >>> assert recon == modpath
        >>> assert rel_modpath == join('xdoctest', 'static_analysis.py')
    """
    modpath_ = abspath(expanduser(modpath))
    if check:
        if not exists(modpath_):
            if not exists(modpath):
                raise ValueError("modpath={} does not exist".format(modpath))
            raise ValueError("modpath={} is not a module".format(modpath))
        if isdir(modpath_) and not exists(join(modpath, "__init__.py")):
            # dirs without inits are not modules
            raise ValueError("modpath={} is not a module".format(modpath))
    full_dpath, fname_ext = split(modpath_)
    _relmod_parts = [fname_ext]
    # Recurse down directories until we are out of the package
    dpath = full_dpath
    while exists(join(dpath, "__init__.py")):
        dpath, dname = split(dpath)
        _relmod_parts.append(dname)
    relmod_parts = _relmod_parts[::-1]
    rel_modpath = os.path.sep.join(relmod_parts)
    return dpath, rel_modpath


def modpath_to_modname(
    modpath, hide_init=True, hide_main=False, check=True, relativeto=None
):
    """
    Determines importable name from file path

    Converts the path to a module (__file__) to the importable python name
    (__name__) without importing the module.

    The filename is converted to a module name, and parent directories are
    recursively included until a directory without an __init__.py file is
    encountered.

    Args:
        modpath (str):
            Module filepath

        hide_init (bool):
            Removes the __init__ suffix. Defaults to True.

        hide_main (bool):
            Removes the __main__ suffix. Defaults to False.

        check (bool):
            If False, does not raise an error if modpath is a dir and does not
            contain an __init__ file. Defaults to True.

        relativeto (str | None):
            If specified, all checks are ignored and this is considered the
            path to the root module. Defaults to None.

    TODO:
        - [ ] Does this need modification to support PEP 420?
              https://www.python.org/dev/peps/pep-0420/

    Returns:
        str: modname

    Raises:
        ValueError: if check is True and the path does not exist

    Example:
        >>> from xdoctest import static_analysis
        >>> modpath = static_analysis.__file__.replace('.pyc', '.py')
        >>> modpath = modpath.replace('.pyc', '.py')
        >>> modname = modpath_to_modname(modpath)
        >>> assert modname == 'xdoctest.static_analysis'

    Example:
        >>> import xdoctest
        >>> assert modpath_to_modname(xdoctest.__file__.replace('.pyc', '.py')) == 'xdoctest'
        >>> assert modpath_to_modname(dirname(xdoctest.__file__.replace('.pyc', '.py'))) == 'xdoctest'

    Example:
        >>> modpath = '/foo/libfoobar.linux-x86_64-3.6.so'
        >>> modname = modpath_to_modname(modpath, check=False)
        >>> assert modname == 'libfoobar'
    """
    if check and relativeto is None:
        if not exists(modpath):
            raise ValueError("modpath={} does not exist".format(modpath))
    modpath_ = abspath(expanduser(modpath))

    modpath_ = normalize_modpath(modpath_, hide_init=hide_init, hide_main=hide_main)
    if relativeto:
        dpath = dirname(abspath(expanduser(relativeto)))
        rel_modpath = relpath(modpath_, dpath)
    else:
        dpath, rel_modpath = split_modpath(modpath_, check=check)

    modname = splitext(rel_modpath)[0]
    if "." in modname:
        modname, abi_tag = modname.split(".", 1)
    modname = modname.replace("/", ".")
    modname = modname.replace("\\", ".")
    return modname


class PythonPathContext:
    """
    Context for temporarily adding a dir to the PYTHONPATH.

    Warning:
        Even though this context manager takes precautions, this modifies
        ``sys.path``, and things can go wrong when that happens.  This is
        generally safe as long as nothing else you do inside of this context
        modifies the path. If the path is modified in this context, we will try
        to detect it and warn.

    Attributes:
        dpath (str | PathLike): directory to insert into the PYTHONPATH
        index (int): position to add to. Typically either -1 or 0.

    Example:
        >>> import sys
        >>> with PythonPathContext('foo', -1):
        >>>     assert sys.path[-1] == 'foo'
        >>> assert sys.path[-1] != 'foo'
        >>> with PythonPathContext('bar', 0):
        >>>     assert sys.path[0] == 'bar'
        >>> assert sys.path[0] != 'bar'

    Example:
        >>> # xdoctest: +REQUIRES(module:pytest)
        >>> # Mangle the path inside the context
        >>> import sys
        >>> self = PythonPathContext('foo', 0)
        >>> self.__enter__()
        >>> sys.path.insert(0, 'mangled')
        >>> import pytest
        >>> with pytest.warns(UserWarning):
        >>>     self.__exit__(None, None, None)

    Example:
        >>> # xdoctest: +REQUIRES(module:pytest)
        >>> import sys
        >>> self = PythonPathContext('foo', 0)
        >>> self.__enter__()
        >>> sys.path.remove('foo')
        >>> import pytest
        >>> with pytest.raises(RuntimeError):
        >>>     self.__exit__(None, None, None)
    """

    def __init__(self, dpath, index=0):
        """
        Args:
            dpath (str | PathLike): directory to insert into the PYTHONPATH
            index (int): position to add to. Typically either -1 or 0.
        """
        self.dpath = os.fspath(dpath)
        self.index = index

    def __enter__(self):
        if self.index < 0:
            self.index = len(sys.path) + self.index + 1
        sys.path.insert(self.index, self.dpath)

    def __exit__(self, ex_type, ex_value, ex_traceback):
        """
        Args:
            ex_type (Type[BaseException] | None):
            ex_value (BaseException | None):
            ex_traceback (TracebackType | None):

        Returns:
            bool | None
        """
        need_recover = False
        if len(sys.path) <= self.index:  # nocover
            msg_parts = [
                "sys.path changed while in PythonPathContext.",
                "len(sys.path) = {!r} but index is {!r}".format(
                    len(sys.path), self.index
                ),
            ]
            need_recover = True

        if sys.path[self.index] != self.dpath:  # nocover
            # The path is not where we put it, the path must have been mangled
            msg_parts = [
                "sys.path changed while in PythonPathContext",
                "Expected dpath={!r} at index={!r} in sys.path, but got "
                "dpath={!r}".format(self.dpath, self.index, sys.path[self.index]),
            ]
            need_recover = True

        if need_recover:
            # Try and find where the temporary path went
            try:
                real_index = sys.path.index(self.dpath)
            except ValueError:
                msg_parts.append("Expected dpath was not in sys.path")
                raise RuntimeError("\n".join(msg_parts))
            else:
                # We were able to recover, but warn the user. This method of
                # recovery is a heuristic and does not work in some cases.
                msg_parts.append(
                    (
                        "Expected dpath was at index {}. "
                        "This could indicate conflicting module namespaces."
                    ).format(real_index)
                )
                warnings.warn("\n".join(msg_parts))
                sys.path.pop(real_index)
        else:
            sys.path.pop(self.index)


def import_module_from_path(modpath, index=-1):
    """
    Imports a module via a filesystem path.

    This works by modifying ``sys.path``, importing the module name, and then
    attempting to undo the change to sys.path. This function may produce
    unexpected results in the case where the imported module itself itself
    modifies ``sys.path`` or if there is another conflicting module with the
    same name.

    Args:
        modpath (str | PathLike):
            Path to the module on disk.

        index (int):
            Location at which we modify PYTHONPATH if necessary.  If your
            module name does not conflict, the safest value is -1, However, if
            there is a conflict, then use an index of 0.  The default may
            change to 0 in the future.

    Returns:
        ModuleType: the imported module

    References:
        .. [SO_67631] https://stackoverflow.com/questions/67631/import-module-given-path

    Raises:
        IOError - when the path to the module does not exist
        ImportError - when the module is unable to be imported

    Note:
        If the module is part of a package, the package will be imported first.
        These modules may cause problems when reloading via IPython magic

    Warning:
        It is best to use this with paths that will not conflict with
        previously existing modules.

        If the modpath conflicts with a previously existing module name. And
        the target module does imports of its own relative to this conflicting
        path. In this case, the module that was loaded first will win.

        For example if you try to import '/foo/bar/pkg/mod.py' from the folder
        structure:

        .. code::

            - foo/
              +- bar/
                 +- pkg/
                    +  __init__.py
                    |- mod.py
                    |- helper.py

       If there exists another module named ``pkg`` already in ``sys.modules``
       and mod.py contains the code ``from . import helper``, Python will
       assume helper belongs to the ``pkg`` module already in ``sys.modules``.
       This can cause a NameError or worse --- an incorrect helper module.

    Example:
        >>> import xdoctest
        >>> modpath = xdoctest.__file__
        >>> module = import_module_from_path(modpath)
        >>> assert module is xdoctest

    Example:
        >>> import pytest
        >>> with pytest.raises(ValueError):
        >>>     import_module_from_path('does-not-exist')
    """
    modpath = os.fspath(modpath)
    # the importlib version does not work in pytest
    dpath, rel_modpath = split_modpath(modpath)
    modname = modpath_to_modname(modpath)
    try:
        with PythonPathContext(dpath, index=index):
            module = importlib.import_module(modname)
    except Exception as ex:  # nocover
        msg_parts = [
            (
                "ERROR: Failed to import modname={} with modpath={} and "
                "sys.path modified with {} at index={}"
            ).format(modname, modpath, repr(dpath), index)
        ]
        msg_parts.append("Caused by: {}".format(repr(ex)))
        raise RuntimeError("\n".join(msg_parts))
    return module
