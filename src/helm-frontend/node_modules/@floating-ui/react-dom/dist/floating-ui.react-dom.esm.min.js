import{arrow as e,computePosition as t}from"@floating-ui/dom";export{autoPlacement,autoUpdate,computePosition,detectOverflow,flip,getOverflowAncestors,hide,inline,limitShift,offset,platform,shift,size}from"@floating-ui/dom";import*as r from"react";import{useLayoutEffect as n,useEffect as o}from"react";import*as u from"react-dom";const i=t=>{const{element:r,padding:n}=t;return{name:"arrow",options:t,fn(t){return o=r,Object.prototype.hasOwnProperty.call(o,"current")?null!=r.current?e({element:r.current,padding:n}).fn(t):{}:r?e({element:r,padding:n}).fn(t):{};var o}}};var c="undefined"!=typeof document?n:o;function f(e,t){if(e===t)return!0;if(typeof e!=typeof t)return!1;if("function"==typeof e&&e.toString()===t.toString())return!0;let r,n,o;if(e&&t&&"object"==typeof e){if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(n=r;0!=n--;)if(!f(e[n],t[n]))return!1;return!0}if(o=Object.keys(e),r=o.length,r!==Object.keys(t).length)return!1;for(n=r;0!=n--;)if(!Object.prototype.hasOwnProperty.call(t,o[n]))return!1;for(n=r;0!=n--;){const r=o[n];if(("_owner"!==r||!e.$$typeof)&&!f(e[r],t[r]))return!1}return!0}return e!=e&&t!=t}function s(e){const t=r.useRef(e);return c((()=>{t.current=e})),t}function l(e){void 0===e&&(e={});const{placement:n="bottom",strategy:o="absolute",middleware:i=[],platform:l,whileElementsMounted:a,open:m}=e,[p,d]=r.useState({x:null,y:null,strategy:o,placement:n,middlewareData:{},isPositioned:!1}),[g,y]=r.useState(i);f(g,i)||y(i);const h=r.useRef(null),w=r.useRef(null),b=r.useRef(p),P=s(a),O=s(l),[S,R]=r.useState(null),[j,k]=r.useState(null),v=r.useCallback((e=>{h.current!==e&&(h.current=e,R(e))}),[]),M=r.useCallback((e=>{w.current!==e&&(w.current=e,k(e))}),[]),x=r.useCallback((()=>{if(!h.current||!w.current)return;const e={placement:n,strategy:o,middleware:g};O.current&&(e.platform=O.current),t(h.current,w.current,e).then((e=>{const t={...e,isPositioned:!0};A.current&&!f(b.current,t)&&(b.current=t,u.flushSync((()=>{d(t)})))}))}),[g,n,o,O]);c((()=>{!1===m&&b.current.isPositioned&&(b.current.isPositioned=!1,d((e=>({...e,isPositioned:!1}))))}),[m]);const A=r.useRef(!1);c((()=>(A.current=!0,()=>{A.current=!1})),[]),c((()=>{if(S&&j){if(P.current)return P.current(S,j,x);x()}}),[S,j,x,P]);const C=r.useMemo((()=>({reference:h,floating:w,setReference:v,setFloating:M})),[v,M]),$=r.useMemo((()=>({reference:S,floating:j})),[S,j]);return r.useMemo((()=>({...p,update:x,refs:C,elements:$,reference:v,floating:M})),[p,x,C,$,v,M])}export{i as arrow,l as useFloating};
